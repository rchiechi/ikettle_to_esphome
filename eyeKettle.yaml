esphome:
  name: "eyekettle"
  friendly_name: "eyeKettle S2"
  includes:
    - kettle_logic.h # Make sure to put this file in the same dir as the yaml
  on_boot:
    # Action 1: High Priority (Runs first)
    - priority: 600
      then:
        # 1. Initialize Binary Sensors
        - binary_sensor.template.publish:
            id: boiling_status
            state: OFF
        - binary_sensor.template.publish:
            id: keeping_warm_status
            state: OFF
        - binary_sensor.template.publish:
            id: kettle_present
            state: ON 

        # 2. Set Text to "Booting"
        - text_sensor.template.publish:
            id: fault_status
            state: "Booting..."

    # Action 2: Low Priority (Runs last, just before the main loop starts)
    - priority: -10
      then:
        - text_sensor.template.publish:
            id: fault_status
            state: "Idle"
    
esp32:
  #board: adafruit_feather_esp32s2
  board: esp32-s2-saola-1
  variant: ESP32S2
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    id: ota_esphome

logger:
  level: DEBUG
  logs:
    # Silence the chatty components
    sensor: INFO
    resistance: INFO
    ntc: INFO
    # Keep custom lambda logging at DEBUG
    component: DEBUG

# -----------------------------------------------------------------
# Configuration variables
# -----------------------------------------------------------------
substitutions:
  temperature_pin: GPIO8  # labeled 'A5' must be ADC1 to avoid wifi conflict
  temperature_resistor: 47kOhm # Ideally 47 - 100 kOhm
  led_pin: GPIO10
  button_pin: GPIO5 # 10 kOhm resistor to 3.3V
  heating_pin: GPIO12
  default_target_temp: 85 # The default target temp on startup
  default_keep_warm: 5 # The default keep warm minutes on startup
  loop_speed_ms: "250"

# -----------------------------------------------------------------
# Do not edit below this line
# -----------------------------------------------------------------


# ----------------------------------------------------------------
# FAULT STATUS SENSOR
# ----------------------------------------------------------------
text_sensor:
  - platform: template
    name: "Kettle Fault Status"
    id: fault_status
    update_interval: never

# ----------------------------------------------------------------
# SENSORS (ADC & NTC)
# ----------------------------------------------------------------
sensor:
  # RAW SENSOR (Physics Engine Input)
  # - Must have ID 'water_temp' because C++ uses it.
  # - Must be INTERNAL to avoid spamming HA database.
  # - Must NOT have 'delta' filter, or rate calculation breaks.
  - platform: ntc
    id: water_temp
    sensor: resistance_sensor
    internal: true 
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 50kOhm
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

  # PUBLIC SENSOR (Home Assistant Display)
  # - This creates the entity in Home Assistant.
  # - Applies the filters to keep the UI clean.
  - platform: copy
    source_id: water_temp
    name: "Water Temperature"
    filters:
      - delta: 0.5

  # 3. INTERNAL HELPERS
  - platform: resistance
    id: resistance_sensor
    internal: true
    sensor: source_sensor
    configuration: DOWNSTREAM
    resistor: ${temperature_resistor}

  - platform: adc
    id: source_sensor
    internal: true
    pin: ${temperature_pin}
    attenuation: 12db
    update_interval: 250ms 
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 2
          

# ----------------------------------------------------------------
# HARDWARE: LED & BUTTON
# ----------------------------------------------------------------

output:
  - platform: ledc
    pin: ${led_pin}
    id: led_gpio
    frequency: 1000Hz

light:
  - platform: monochromatic
    name: "Kettle LED"
    output: led_gpio
    id: kettle_led
    internal: true # Hide from HA

binary_sensor:
  - platform: gpio
    pin:
      number: ${button_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "Physical Button"
    id: physical_button
    internal: true # Hide from HA, we send events instead
    on_multi_click:
      - timing:
          - ON for at most 1s
          - OFF for at most 1s
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - homeassistant.event:
              event: esphome.kettle_button_event
              data:
                click_type: double
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - homeassistant.event:
              event: esphome.kettle_button_event
              data:
                click_type: single
    
    # ----------------------------------------------------------------
    # GLOBAL STATE SENSORS
    # ----------------------------------------------------------------

  - platform: template
    name: "Boiling"
    id: boiling_status
    icon: "mdi:kettle-steam"
    
  - platform: template
    name: "Keep Warm"
    id: keeping_warm_status
    icon: "mdi:thermometer-check"

  - platform: template
    name: "Kettle Present"
    id: kettle_present
    icon: "mdi:kettle-alert-outline"

# ----------------------------------------------------------------
# HARDWARE SWITCH (Updated)
# ----------------------------------------------------------------
switch:
  - platform: gpio
    pin: ${heating_pin}
    id: relay_hardware
    internal: true
    restore_mode: ALWAYS_OFF
    
    # START the watchdog when relay turns ON
    on_turn_on:
      - script.execute: safety_watchdog
      
    # KILL the watchdog when relay turns OFF
    # This prevents "zombie timers" from killing your Keep Warm session
    on_turn_off:
      - script.stop: safety_watchdog


  # ----------------------------------------------------------------
  # 2. UI SWITCH 
  # ----------------------------------------------------------------
  - platform: template
    name: "Heating Element"
    id: kettle_active
    icon: "mdi:kettle"
    optimistic: true
    turn_on_action:
      - lambda: 'id(fault_status).publish_state("Heating");'
    turn_off_action:
      - switch.turn_off: relay_hardware
      - lambda: 'id(fault_status).publish_state("Idle");'


# ----------------------------------------------------------------
# SAFETY WATCHDOG SCRIPT
# ----------------------------------------------------------------
script:
  - id: safety_watchdog
    mode: restart
    then:
      - delay: 30min
      
      # Use standard YAML action instead of C++ syntax
      - switch.turn_off: relay_hardware
      - switch.turn_off: kettle_active
      
      # Set status LAST so it overwrites the "Idle" status from kettle_active
      - lambda: 'id(fault_status).publish_state("Safety Timeout");'
      - logger.log: "Emergency Safety Cutoff Triggered!"

# ----------------------------------------------------------------
# 3. UI SLIDERS (Target & Timer)
# ----------------------------------------------------------------
number:
  - platform: template
    name: "Target Temperature"
    id: target_temp
    icon: "mdi:thermometer-lines"
    unit_of_measurement: "°C"
    min_value: 40
    max_value: 100
    step: 1
    restore_value: true
    initial_value: ${default_target_temp}
    optimistic: true

  - platform: template
    name: "Keep Warm Time"
    id: keep_warm_mins
    icon: "mdi:timer-outline"
    unit_of_measurement: "min"
    min_value: 0
    max_value: 30
    step: 1
    restore_value: true
    initial_value: ${default_keep_warm}
    optimistic: true

# ----------------------------------------------------------------
# 4. CONTROL LOOP (The Brains)
# ----------------------------------------------------------------
interval:
  # Append 'ms' for the scheduler
  - interval: ${loop_speed_ms}ms
    then:
      # Pass the raw number to C++ logic
      - lambda: 'kettle_logic.loop(${loop_speed_ms});'