esphome:
  name: "eyekettle"
  friendly_name: "eyeKettle S2"
  includes:
    - kettle_logic.h
  
  on_boot:
    # Action 1: High Priority (Runs first)
    - priority: 600
      then:
        # 1. Initialize Binary Sensors
        - binary_sensor.template.publish:
            id: boiling_status
            state: OFF
        - binary_sensor.template.publish:
            id: keeping_warm_status
            state: OFF
        - binary_sensor.template.publish:
            id: kettle_present
            state: ON 

        # 2. Set Text to "Booting"
        - text_sensor.template.publish:
            id: fault_status
            state: "Booting..."

    # Action 2: Low Priority (Runs last, just before the main loop starts)
    - priority: -10
      then:
        - text_sensor.template.publish:
            id: fault_status
            state: "Idle"
    
esp32:
  #board: adafruit_feather_esp32s2
  board: esp32-s2-saola-1
  variant: ESP32S2
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: ! secret_api_encryption_key

ota:
  - platform: esphome
    id: ota_esphome

logger:
  level: DEBUG
  logs:
    hx711: INFO # Comment for calibration, only uncomment if using HX711
    # Silence the chatty components
    sensor: INFO
    resistance: INFO
    ntc: INFO
    # Keep custom lambda logging at DEBUG
    component: DEBUG

# -----------------------------------------------------------------
# Configuration variables
# -----------------------------------------------------------------
substitutions:
  temperature_pin: GPIO8  # labeled 'A5' must be ADC1 to avoid wifi conflict
  temperature_resistor: 47kOhm # Ideally 47 - 100 kOhm
  led_pin: GPIO10
  button_pin: GPIO5 # 10 kOhm resistor to 3.3V
  heating_pin: GPIO12
  default_target_temp: 85 # The default target temp on startup
  default_keep_warm: 5 # The default keep warm minutes on startup
  loop_speed_ms: "250"

# -----------------------------------------------------------------
# Do not edit below this line
# -----------------------------------------------------------------


# ----------------------------------------------------------------
# FAULT STATUS SENSOR
# ----------------------------------------------------------------
text_sensor:
  - platform: template
    name: "Kettle Fault Status"
    id: fault_status
    update_interval: never

# ----------------------------------------------------------------
# SENSORS
# ----------------------------------------------------------------
sensor:
  # RAW TEMP SENSOR (For internal calculations)
  # - Must have ID 'water_temp' because C++ uses it.
  # - Must be INTERNAL to avoid spamming HA database.
  # - Must NOT have 'delta' filter, or rate calculation breaks.
  - platform: ntc
    id: water_temp
    sensor: resistance_sensor
    internal: true 
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 50kOhm
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

  # PUBLIC TEMP SENSOR (Home Assistant Display)
  # Heavy filtering for a "Stable" look. 
  # Does not affect the C++ calculations.
  - platform: copy
    source_id: water_temp
    name: "Water Temperature"
    accuracy_decimals: 0 # Display whole numbers (e.g. "42 °C")
    filters:
      # HEAVY SMOOTHING
      # Slow layer of smoothing just for the display.
      # Window 15 @ 250ms updates = ~3.75 seconds of averaging.
      - sliding_window_moving_average:
          window_size: 15
          send_every: 1

      # ROUNDING
      # Force value to nearest integer (41.6 -> 42.0)
      - round: 0

      # HYSTERESIS / DELTA
      # Only update HA if the integer value actually changes.
      # Prevents "42" -> "42" updates.
      - delta: 1.0

  # INTERNAL HELPERS
  - platform: resistance
    id: resistance_sensor
    internal: true
    sensor: source_sensor
    configuration: DOWNSTREAM
    resistor: ${temperature_resistor}

  - platform: adc
    id: source_sensor
    internal: true
    pin: ${temperature_pin}
    attenuation: 12db
    update_interval: 250ms 
    filters:
      - sliding_window_moving_average:
          window_size: 10
          send_every: 2

########################################################################
#  Comment out the blocks below if you are not using the strain gauge  #
########################################################################
  # HX711 Strain Gauge
  - platform: hx711
    name: "HX711 Internal"
    id: strain_sensor
    internal: true
    dout_pin:
      number: 6   # DATA
      mode: INPUT_PULLUP
    clk_pin: 9    # CLOCK / SCK
    gain: 64
    update_interval: 1s 
    filters:
      # CALIBRATION (Based on your averages)
      # Maps raw weight directly to Percentage (0.0 - 100.0)
      - calibrate_linear:
          - -435300 -> 0.0 # Point 1: Empty
          - -357900 -> 1.0 # Point 2: 1.0 Liter
          - -295600 -> 1.8 # Point 3: 1.8 Liters (Full)

      # LIGHT SMOOTHING
      # Just enough to strip electrical noise for the C++ logic
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1      
    ##################################################
    # These are my values: yours will be different!  #
    # No Kettle: -522425 / -520781                   #
    # Empty Kettle: -434452 / -436118                #
    # 1 L of water in Kettle: -356995 / -358771      #
    # Full Kettle: -295012 /  -296228                #
    ##################################################
  - platform: copy
    source_id: strain_sensor
    name: "Water Level"
    unit_of_measurement: "%"
    icon: "mdi:kettle-steam"
    accuracy_decimals: 0 # Show "50 %", not "50.0 %"
    filters:
      # CONVERT LITERS TO PERCENT
      # Logic: (Liters / 1.8) * 100
      - lambda: return (x / 1.8) * 100.0;

      # CLAMP floor to 0%
      - lambda: |-
          return x < 0 ? 0 : x;

      # HEAVY SMOOTHING FOR STABLE READINGS
      - sliding_window_moving_average:
          window_size: 20
          send_every: 1

      # QUANTIZE to 10%
      - lambda: return round(x / 10.0) * 10.0;
      
      # HYSTERESIS
      - delta: 5
########################################################################
#  End of strain gauge logic                                           #
########################################################################


# ----------------------------------------------------------------
# HARDWARE: LED & BUTTON
# ----------------------------------------------------------------

output:
  - platform: ledc
    pin: ${led_pin}
    id: led_gpio
    frequency: 1000Hz

light:
  - platform: monochromatic
    name: "Kettle LED"
    output: led_gpio
    id: kettle_led
    internal: true # Hide from HA

binary_sensor:
  - platform: gpio
    pin:
      number: ${button_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "Physical Button"
    id: physical_button
    internal: true # Hide from HA, we send events instead
    on_multi_click:
      - timing:
          - ON for at most 1s
          - OFF for at most 1s
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - homeassistant.event:
              event: esphome.kettle_button_event
              data:
                click_type: double
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - homeassistant.event:
              event: esphome.kettle_button_event
              data:
                click_type: single
    
    # ----------------------------------------------------------------
    # GLOBAL STATE SENSORS
    # ----------------------------------------------------------------

  - platform: template
    name: "Boiling"
    id: boiling_status
    icon: "mdi:kettle-steam"
    
  - platform: template
    name: "Keeping Warm"
    id: keeping_warm_status
    icon: "mdi:thermometer-check"

  - platform: template
    name: "Kettle Present"
    id: kettle_present
    icon: "mdi:kettle-alert-outline"

# ----------------------------------------------------------------
# HARDWARE SWITCH (Updated)
# ----------------------------------------------------------------
switch:
  - platform: gpio
    pin: ${heating_pin}
    id: relay_hardware
    internal: true
    restore_mode: ALWAYS_OFF
    
    # START the watchdog when relay turns ON
    on_turn_on:
      - script.execute: safety_watchdog
      
    # KILL the watchdog when relay turns OFF
    # This prevents "zombie timers" from killing your Keep Warm session
    on_turn_off:
      - script.stop: safety_watchdog


  # ----------------------------------------------------------------
  # 2. UI SWITCH 
  # ----------------------------------------------------------------
  - platform: template
    name: "Heating Element"
    id: kettle_active
    icon: "mdi:kettle"
    optimistic: true
    turn_on_action:
      - lambda: 'id(fault_status).publish_state("Heating");'
    turn_off_action:
      - switch.turn_off: relay_hardware
      - lambda: 'id(fault_status).publish_state("Idle");'


# ----------------------------------------------------------------
# SAFETY WATCHDOG SCRIPT
# ----------------------------------------------------------------
script:
  - id: safety_watchdog
    mode: restart
    then:
      - delay: 30min
      
      # Use standard YAML action instead of C++ syntax
      - switch.turn_off: relay_hardware
      - switch.turn_off: kettle_active
      
      # Set status LAST so it overwrites the "Idle" status from kettle_active
      - lambda: 'id(fault_status).publish_state("Safety Timeout");'
      - logger.log: "Emergency Safety Cutoff Triggered!"

# ----------------------------------------------------------------
# 3. UI SLIDERS (Target & Timer)
# ----------------------------------------------------------------
number:
  - platform: template
    name: "Target Temperature"
    id: target_temp
    icon: "mdi:thermometer-lines"
    unit_of_measurement: "°C"
    min_value: 40
    max_value: 100
    step: 1
    restore_value: true
    initial_value: ${default_target_temp}
    optimistic: true

  - platform: template
    name: "Keep Warm Time"
    id: keep_warm_mins
    icon: "mdi:timer-outline"
    unit_of_measurement: "min"
    min_value: 0
    max_value: 30
    step: 1
    restore_value: true
    initial_value: ${default_keep_warm}
    optimistic: true

# ----------------------------------------------------------------
# 4. CONTROL LOOP (The Brains)
# ----------------------------------------------------------------
interval:
  # Append 'ms' for the scheduler
  - interval: ${loop_speed_ms}ms
    then:
      # Pass the raw number to C++ logic
      - lambda: 'kettle_logic.loop(${loop_speed_ms});'